# 物品放置游戏 - 技术设计文档

## 1. 游戏概述

### 1.1 游戏类型
物品放置类益智游戏，玩家需要将不同形状的物品放入有限空间的仓库中，目标是尽可能高效地利用仓库空间。

### 1.2 核心玩法
- 玩家从物品面板中获取随机生成的物品
- 通过拖拽将物品放入7x5的仓库网格中
- 物品之间不能重叠
- 物品不能超出仓库边界
- 通过刷新按钮获取新的物品组合

### 1.3 游戏目标
- 最大化仓库空间利用率
- 合理安排物品位置
- 规划物品放置顺序

## 2. 核心系统设计

### 2.1 仓库系统

#### 2.1.1 仓库结构
- **网格大小**：7列 × 5行（35个格子）
- **格子尺寸**：可配置的像素大小（默认80像素）
- **格子间距**：可配置的间距（默认5像素）
- **锚点系统**：所有格子使用左上角锚点 (0, 1)

#### 2.1.2 仓库功能
- **网格渲染**：自动生成并显示仓库网格
- **位置计算**：将世界坐标转换为网格坐标
- **边界检测**：检查物品是否超出仓库范围
- **重叠检测**：检查物品之间是否重叠
- **物品管理**：维护已放置物品的列表

#### 2.1.3 坐标系统
- **世界坐标**：基于仓库容器的本地坐标
- **网格坐标**：行列索引 (row, col)，从 (0,0) 开始
- **转换规则**：
  - 第一个格子左上角位置：(-totalWidth/2, totalHeight/2)
  - 格子位置计算：startX + col × (cellSize + spacing)
  - 行位置计算：startY - row × (cellSize + spacing)

### 2.2 物品系统

#### 2.2.1 物品定义
每个物品包含以下属性：
- **唯一ID**：用于标识物品类型
- **名称**：物品的显示名称
- **形状**：二维数组，1表示占用，0表示不占用
- **颜色**：用于视觉区分
- **描述**：物品的说明文字
- **类型**：物品分类（square, l_shape, bar等）
- **锚点**：物品的基准方块位置（默认左上角第一个方块）

#### 2.2.2 物品形状
物品形状以左上角为原点，向下向右扩展：
- 形状数组的行表示从上到下的位置
- 形状数组的列表示从左到右的位置
- 1表示该位置被占用，0表示空位

#### 2.2.3 物品类型（10种）
1. **2x2正方形**：基础方块，占用4格
2. **L形（缺右下角）**：3×3形状，缺一个角
3. **反L形（缺左下角）**：3×3形状，缺一个角
4. **横向3格长条**：1×3形状
5. **纵向3格长条**：3×1形状
6. **T形**：3×2形状，T字型
7. **倒T形**：3×2形状，倒T字型
8. **Z形**：3×2形状，Z字型
9. **反Z形**：3×2形状，反Z字型
10. **单格**：1×1形状，最小单位

### 2.3 拖拽系统

#### 2.3.1 拖拽流程
1. **开始拖拽**：玩家点击物品槽位中的物品
2. **拖拽中**：显示拖拽预览，跟随鼠标移动
3. **预览显示**：在仓库上方显示物品放置预览
   - 绿色：可以放置（不重叠、不越界）
   - 红色：不能放置（重叠或越界）
4. **结束拖拽**：松开鼠标
   - 在有效位置：放置物品，从槽位移除
   - 在无效位置：取消放置，物品返回槽位

#### 2.3.2 拖拽管理器
- **单例模式**：全局唯一的拖拽管理器
- **状态管理**：跟踪当前拖拽的物品和源槽位
- **预览渲染**：创建并更新拖拽预览
- **事件处理**：处理全局触摸事件

#### 2.3.3 坐标转换
- **屏幕坐标** → **仓库本地坐标**：使用UITransform转换
- **仓库本地坐标** → **网格坐标**：考虑物品锚点
- **网格坐标** → **物品位置**：计算物品容器的左上角位置

### 2.4 物品面板系统

#### 2.4.1 面板结构
- **槽位数量**：3个物品槽位
- **刷新按钮**：重新生成3个随机物品
- **自动生成**：场景加载时自动生成初始物品

#### 2.4.2 物品生成
- **随机选择**：从10种物品类型中随机选择
- **避免重复**：尽量选择不同的物品类型
- **允许重复**：如果物品类型不足，允许重复

#### 2.4.3 槽位管理
- **物品显示**：可视化显示物品形状
- **物品移除**：物品放置成功后自动清空
- **状态同步**：实时更新槽位状态

## 3. 核心算法

### 3.1 重叠检测算法

#### 3.1.1 检测流程
1. 获取物品所有占用位置（相对于物品左上角）
2. 将占用位置转换为仓库网格坐标
3. 检查每个占用位置是否已被其他物品占用
4. 如果所有位置都未被占用，则可以放置

#### 3.1.2 边界检测
- 检查物品左上角第一个方块的位置是否在有效范围内
- 检查物品右下角最后一个方块是否超出仓库边界
- 考虑物品的宽度和高度

### 3.2 位置计算算法

#### 3.2.1 网格坐标计算
- 输入：鼠标的世界坐标
- 输出：物品左上角第一个方块应该放置的网格坐标
- 考虑因素：
  - 物品的锚点位置
  - 格子的起始位置
  - 格子的尺寸和间距

#### 3.2.2 物品位置计算
- 输入：网格坐标 (row, col)
- 输出：物品容器的世界坐标
- 计算步骤：
  1. 计算目标格子的左上角位置
  2. 根据物品尺寸计算容器位置
  3. 考虑锚点偏移（如果需要）

### 3.3 预览显示算法

#### 3.3.1 预览位置
- 使用与实际放置相同的位置计算逻辑
- 确保预览位置与实际放置位置完全一致

#### 3.3.2 预览颜色
- **绿色**：所有占用位置都未被占用，且不越界
- **红色**：存在重叠或越界情况

## 4. 数据结构设计

### 4.1 物品数据
- **BaseItem**：物品基类，包含所有物品的通用属性
- **ItemShape**：二维数组类型，定义物品形状
- **PlacedItemData**：已放置物品的数据结构
  - 物品引用
  - 放置位置（row, col）

### 4.2 仓库数据
- **网格节点列表**：存储所有格子节点的引用
- **已放置物品列表**：存储所有已放置物品的数据
- **配置参数**：列数、行数、格子大小、间距等

### 4.3 拖拽数据
- **当前拖拽物品**：正在拖拽的物品引用
- **源槽位**：物品来源的槽位节点
- **拖拽状态**：是否正在拖拽
- **预览节点**：拖拽预览的节点引用

## 5. 交互流程

### 5.1 游戏初始化流程
1. 场景加载
2. 创建仓库网格
3. 初始化拖拽管理器
4. 创建物品面板
5. 生成初始物品（3个）

### 5.2 物品放置流程
1. 玩家点击物品槽位
2. 开始拖拽，显示拖拽预览
3. 鼠标移动，更新预览位置
4. 在仓库上方显示放置预览（绿/红）
5. 松开鼠标
6. 检查放置位置是否有效
7. 如果有效：放置物品，从槽位移除
8. 如果无效：取消放置

### 5.3 刷新流程
1. 玩家点击刷新按钮
2. 清空当前槽位
3. 随机生成3个新物品
4. 更新槽位显示

## 6. 视觉反馈系统

### 6.1 预览反馈
- **拖拽预览**：半透明显示，跟随鼠标
- **放置预览**：在仓库中显示，颜色表示可放置性
- **预览大小**：使用仓库的格子大小，确保一致性

### 6.2 状态反馈
- **槽位状态**：显示/隐藏物品
- **仓库状态**：显示已放置的物品
- **按钮状态**：刷新按钮的交互反馈

### 6.3 颜色系统
- **物品颜色**：每种物品类型有独特的颜色
- **预览颜色**：绿色（可放置）、红色（不可放置）
- **网格颜色**：边框和填充颜色可配置

## 7. 扩展性设计

### 7.1 物品扩展
- **添加新物品**：继承BaseItem类，定义形状和属性
- **注册机制**：通过工厂模式统一管理
- **配置化**：形状、颜色等可通过配置文件定义

### 7.2 仓库扩展
- **尺寸配置**：支持不同大小的仓库
- **格子样式**：可自定义格子的外观
- **布局方式**：支持不同的网格布局

### 7.3 游戏机制扩展
- **旋转功能**：物品可以旋转90度
- **撤销功能**：撤销最后一次放置
- **计分系统**：根据空间利用率计分
- **关卡系统**：不同难度的关卡
- **提示系统**：显示可放置位置
- **自动放置**：AI辅助放置

### 7.4 UI扩展
- **物品信息面板**：显示物品详细信息
- **统计面板**：显示放置统计
- **设置面板**：游戏设置选项
- **帮助面板**：游戏说明和教程

## 8. 性能优化考虑

### 8.1 渲染优化
- **对象池**：复用格子节点和预览节点
- **批量渲染**：合并相同类型的绘制操作
- **视口裁剪**：只渲染可见区域

### 8.2 计算优化
- **空间索引**：使用空间数据结构加速碰撞检测
- **缓存机制**：缓存计算结果，避免重复计算
- **增量更新**：只更新变化的部分

### 8.3 内存优化
- **及时释放**：销毁不再使用的节点
- **资源管理**：合理管理资源引用
- **数据结构优化**：使用高效的数据结构

## 9. 用户体验设计

### 9.1 操作体验
- **拖拽流畅**：预览跟随鼠标，无延迟
- **视觉反馈**：清晰的预览颜色和位置
- **操作容错**：允许取消放置，物品返回槽位

### 9.2 视觉体验
- **一致性**：所有组件使用统一的锚点和坐标系统
- **清晰度**：物品形状清晰可见
- **美观性**：合理的颜色搭配和布局

### 9.3 反馈体验
- **即时反馈**：操作立即显示结果
- **状态提示**：清晰的状态指示
- **错误提示**：无效操作有明确的视觉反馈

## 10. 技术架构

### 10.1 组件架构
- **组件化设计**：每个功能模块独立组件
- **职责分离**：UI、逻辑、数据分离
- **松耦合**：组件之间通过事件通信

### 10.2 设计模式
- **单例模式**：拖拽管理器、物品工厂
- **工厂模式**：物品创建和管理
- **观察者模式**：事件系统

### 10.3 数据流
- **单向数据流**：用户操作 → 状态更新 → UI更新
- **状态管理**：集中管理游戏状态
- **事件驱动**：通过事件触发状态变化

## 11. 未来规划

### 11.1 短期目标
- 完善核心玩法
- 优化用户体验
- 添加音效和动画

### 11.2 中期目标
- 添加旋转功能
- 实现计分系统
- 添加关卡系统

### 11.3 长期目标
- 多人在线模式
- 排行榜系统
- 自定义物品编辑器
- 成就系统

## 12. 技术要点总结

### 12.1 坐标系统
- 统一使用左上角锚点
- 清晰的坐标转换规则
- 一致的坐标计算方式

### 12.2 碰撞检测
- 高效的网格检测算法
- 准确的边界判断
- 实时的重叠检测

### 12.3 交互设计
- 流畅的拖拽体验
- 清晰的视觉反馈
- 直观的操作方式

### 12.4 扩展性
- 灵活的组件架构
- 可配置的参数系统
- 易于扩展的接口设计

---

**文档版本**：v1.0  
**最后更新**：2026-02-18  
**维护者**：开发团队

## 13. 坐标错位问题专项修复计划（预显示/放置后位置不一致）

### 13.1 问题定义（当前现象）
- **问题A：放置前显示错位**：拖拽中的物品显示（手上跟随）与仓库内预显示（绿/红）位置不准确。
- **问题B：预显示与实际放置不一致**：松手后放置结果与预显示位置不一致。
- **问题C：放置后位置偏差**：已放置物品相对于目标网格存在整体偏移（行列对不齐）。

### 13.2 根因假设
- **坐标系混用**：屏幕坐标、UI世界坐标、仓库本地坐标之间转换不统一。
- **锚点不一致**：拖拽预览、仓库格子、已放置物品节点使用了不同锚点（如中心点和左上角混用）。
- **单元尺寸口径不一致**：`cellSize` / `spacing` 在不同模块（拖拽/预览/放置）计算口径不同。
- **基准点不一致**：预显示使用格子中心，放置使用左上角，导致最终偏移。
- **舍入策略不一致**：网格行列计算时 `floor/round/ceil` 使用不统一，边界区域抖动明显。

### 13.3 修复目标
- 预显示位置与最终放置位置完全一致（像素级重合）。
- 拖拽物品的“基准方块”在视觉上与目标网格对齐，无额外偏移。
- 所有位置计算仅保留一套统一算法，避免重复实现和偏差。

### 13.4 技术方案（统一坐标管线）
1. **统一坐标原点与锚点**
   - 仓库网格、预显示、已放置物品统一采用左上角锚点语义。
   - 明确物品“锚点方块”定义：默认形状数组中左上第一个占用格。

2. **单一位置计算入口**
   - 新增或收敛为统一方法（建议在 `Warehouse`）：
     - `screenToWarehouseLocal(screenPos)`
     - `localToGrid(localPos, itemAnchorOffset)`
     - `gridToLocalTopLeft(row, col)`
     - `gridToPlacedItemPosition(row, col, itemConfig)`
   - `DragManager` 和 `PlacedItem` 不再各自实现独立位置公式，只调用统一方法。

3. **统一网格吸附规则**
   - 行列计算统一用同一种舍入方式（建议 `floor` + 边界裁剪）。
   - 边界裁剪规则固定：先算 row/col，再按物品包围盒进行可放置性判断。

4. **统一预显示与放置流程**
   - 预显示和最终放置都复用同一个 `grid -> local position` 结果。
   - 先得到候选 `row/col`，再由同一函数计算预显示坐标和最终坐标。

5. **调试可视化（临时）**
   - 增加可开关日志：输出 screen/local/grid/placedPosition。
   - 可选绘制调试标记（目标格左上角点、物品锚点点）用于肉眼校验。

### 13.5 实施步骤（对应代码文件）
1. **`Warehouse.ts`**
   - 增加统一坐标转换与网格定位 API。
   - 明确格子起始点、间距、边界裁剪和锚点偏移计算。

2. **`DragManager.ts`**
   - 拖拽中预显示只走 `Warehouse` 统一 API。
   - 删除或停用重复的本地坐标/网格计算逻辑。

3. **`PlacedItem.ts`**
   - 放置后位置计算改为复用 `Warehouse` 的 `gridToPlacedItemPosition`。
   - 保证与预显示使用同一输入（row/col）和同一输出口径。

4. **联调与回归**
   - 对 10 种形状逐一拖拽测试（中心、四角、边界、重叠场景）。
   - 验证红绿预显示与放置结果一致；无 1 格偏差、无半格偏差。

### 13.6 验收标准
- 在任意可放置位置，预显示和最终落点重合（目测 + 日志一致）。
- 在边界位置，预显示红/绿判定与最终可放置性一致。
- 不同形状（特别是不规则形状）都保持同样对齐精度。
- 刷新物品、重复拖拽、多次放置后不出现累积偏移。

### 13.7 风险与规避
- **风险1：历史逻辑依赖旧锚点**  
  规避：保留兼容开关，逐模块切换并对比。
- **风险2：UI层级变换导致额外偏移**  
  规避：统一通过目标容器 `UITransform` 做坐标转换，禁止跨层直接算偏移。
- **风险3：边界吸附体验变化**  
  规避：锁定并文档化舍入策略，避免后续被不同模块改写。

### 13.8 后续执行说明
- 本计划通过后，下一步按 13.5 步骤直接改代码（优先 `Warehouse.ts`）。
- 每完成一个文件即进行小步验证，最后做完整回归测试。
